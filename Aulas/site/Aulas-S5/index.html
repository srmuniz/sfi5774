


<!doctype html>
<html lang="pt" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Complemento _online_ às aulas da disciplina de Mecânica Quântica Aplicada do IFSC/USP">
      
      
        <link rel="canonical" href="https://srmuniz.github.io/sfi5774/Aulas-S5/">
      
      
        <meta name="author" content="Sérgio R. Muniz @IFSC/USP">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-5.1.0">
    
    
      
        <title>Aulas S5 - SFI5774</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.89dc9fe3.min.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/palette.ecd4686e.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    <body dir="" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#5-estrutura-matematica-da-mecanica-quantica" class="md-skip">
          Ir para o conteúdo
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="">
    <a href="https://srmuniz.github.io/sfi5774/" title="SFI5774" class="md-header-nav__button md-logo" aria-label="SFI5774">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,8A3,3 0 0,0 15,5A3,3 0 0,0 12,2A3,3 0 0,0 9,5A3,3 0 0,0 12,8M12,11.54C9.64,9.35 6.5,8 3,8V19C6.5,19 9.64,20.35 12,22.54C14.36,20.35 17.5,19 21,19V8C17.5,8 14.36,9.35 12,11.54Z" /></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            SFI5774
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Aulas S5
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" /></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Buscar" placeholder="Buscar" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" /></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" /></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Digite para iniciar a busca
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://srmuniz.github.io/sfi5774" title="Ir ao repositório" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    sfi5774/Aulas/
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="https://srmuniz.github.io/sfi5774/" title="SFI5774" class="md-nav__button md-logo" aria-label="SFI5774">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,8A3,3 0 0,0 15,5A3,3 0 0,0 12,2A3,3 0 0,0 9,5A3,3 0 0,0 12,8M12,11.54C9.64,9.35 6.5,8 3,8V19C6.5,19 9.64,20.35 12,22.54C14.36,20.35 17.5,19 21,19V8C17.5,8 14.36,9.35 12,11.54Z" /></svg>

    </a>
    SFI5774
  </label>
  
    <div class="md-nav__source">
      
<a href="https://srmuniz.github.io/sfi5774" title="Ir ao repositório" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    sfi5774/Aulas/
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../Aulas_S5-S6/" title="Aulas S5 & S6" class="md-nav__link">
      Aulas S5 & S6
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../Aulas_S7/" title="Aulas S7" class="md-nav__link">
      Aulas S7
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../about/" title="About" class="md-nav__link">
      About
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Índice">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
      </span>
      Índice
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#51-espaco-de-estados" class="md-nav__link">
    5.1  Espaço de estados
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#52-espaco-vetorial-linear" class="md-nav__link">
    5.2 Espaço vetorial linear
  </a>
  
    <nav class="md-nav" aria-label="5.2 Espaço vetorial linear">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dimensao-do-espaco" class="md-nav__link">
    Dimensão do espaço
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#53-espacos-de-hilbert-espacos-vetoriais-da-mq" class="md-nav__link">
    5.3 Espaços de Hilbert: espaços vetoriais da MQ
  </a>
  
    <nav class="md-nav" aria-label="5.3 Espaços de Hilbert: espaços vetoriais da MQ">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#produto-interno" class="md-nav__link">
    Produto interno
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comprimentos-e-angulos" class="md-nav__link">
    Comprimentos e ângulos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expansao-de-vetores" class="md-nav__link">
    Expansão de vetores
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#54-notacao-de-dirac" class="md-nav__link">
    5.4 Notação de Dirac
  </a>
  
    <nav class="md-nav" aria-label="5.4 Notação de Dirac">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#propriedades-do-produto-interno" class="md-nav__link">
    Propriedades do produto interno
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#55-vetores-de-base" class="md-nav__link">
    5.5 Vetores de base
  </a>
  
    <nav class="md-nav" aria-label="5.5 Vetores de base">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#procedimento-de-gram-schmidt" class="md-nav__link">
    Procedimento de Gram-Schmidt
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algebra-de-dirac" class="md-nav__link">
    Algebra de Dirac
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#56-operadores-lineares" class="md-nav__link">
    5.6 Operadores lineares
  </a>
  
    <nav class="md-nav" aria-label="5.6 Operadores lineares">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#exemplos-importantes" class="md-nav__link">
    Exemplos importantes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#representacao-de-operadores" class="md-nav__link">
    Representação de operadores
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#valores-esperados" class="md-nav__link">
    Valores esperados
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#autovalores-e-autovetores" class="md-nav__link">
    Autovalores e autovetores
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conjugacao-hermitiana" class="md-nav__link">
    Conjugação Hermitiana
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operadores-hermitianos" class="md-nav__link">
    Operadores Hermitianos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operadores-unitarios" class="md-nav__link">
    Operadores Unitários
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comutadores" class="md-nav__link">
    Comutadores
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conjunto-completo-de-observaveis-que-comutam-ccoc" class="md-nav__link">
    Conjunto Completo de Observáveis que Comutam (CCOC)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  
                
                
                <p><span><span class="MathJax_Preview">\newcommand{\bra}[1]{\left\langle #1 \right|}</span><script type="math/tex">\newcommand{\bra}[1]{\left\langle #1 \right|}</script></span>
<span><span class="MathJax_Preview">\newcommand{\ket}[1]{\left| #1 \right\rangle}</span><script type="math/tex">\newcommand{\ket}[1]{\left| #1 \right\rangle}</script></span>
<span><span class="MathJax_Preview">\newcommand{\braket}[3]{\left\langle #1 \middle| #2 \middle| #3 \right\rangle}</span><script type="math/tex">\newcommand{\braket}[3]{\left\langle #1 \middle| #2 \middle| #3 \right\rangle}</script></span></p>
<h1 id="5-estrutura-matematica-da-mecanica-quantica">5. Estrutura matemática da Mecânica Quântica</h1>
<p>Até este ponto, discutimos, em linhas gerais, como expressar e resolver problemas físicos na mecânica quântica, em termos da Equação de
Schrödinger (EqS). Discutimos, de uma maneira ampla, as estratégias para resolver a EqS no caso geral e, em particular, discutimos a resolução da equação  independente do tempo, resolvendo alguns exemplos emblemáticos de potencias unidimencionais simples. 
Visto sob essa perspectiva, pode-se ter a impressão que mecânica quântica se resume à solução da EqS, usando métodos matemáticos mais ou menos familiares (solução de equações diferenciais parciais). Embora essa seja uma estratégia válida e efetiva em alguns casos, ela é bastante limitada 
e seria um grande equívoco pensar que as estratégias da mecânica quântica se limitam simplesmente a soluções da Eq. de Schrödinger.</p>
<p>O roteiro seguido até aqui teve uma motivação didática e, deliberamente, procurou enfatizar os aspectos físicos do problema. Apresentando apenas a matemática necessária para formular e resolver o problema. Por essa razão, não temos sido muito rigorosos com o formalismo. Trocando rigor matemático por intuição física, sempre que possível, para não obscurecer desnecessariamente a "Física" do problema. Essa estratégia é bastante razoável para uma introdução ao assunto. Apesar disso, o domínio do formalismo matemático também é importante e necessário para ser bem sucedido na resolução de problemas gerais da MQ, ou mesmo para entender muitos temas de pesquisa contemporânea. A situação ideal é aquela onde consegue-se combinar ambas habilidades, que é um dos objetivos secundários deste curso.</p>
<p>Neste capitulo, portanto, seguiremos uma estratégia diferente e complementar àquela seguida até agora. O foco agora será ampliar a linguagem e abstração do problema, apresentadno de modo mais formal a estrutura matemática da mecânica quântica moderna. A prioridade ainda permanecerá com a Física e não a Matemática. Portanto, não se almeja mero rigor matemático, mas, sim, introduzir novos conceitos e representações que serão muito úteis para expandir os horizontes dentro da teoria e, como iremos explorar nos próximos capítulos, serão fundamentais para entender a linguagem contemporânea dessa importante disciplina científica.</p>
<h2 id="51-espaco-de-estados">5.1  Espaço de estados</h2>
<p>Resumindo o que vimos até aqui, podemos, ainda de uma maneira informal, dizer que as soluções estacionárias <span><span class="MathJax_Preview">\psi_n(x)</span><script type="math/tex">\psi_n(x)</script></span> da EqS são funções de ondas que representam os possíveis estados do sistema, com energia <span><span class="MathJax_Preview">E_n</span><script type="math/tex">E_n</script></span>. Outra forma de dizer isso, motivada pela forma da equação <span><span class="MathJax_Preview">H\psi_n(x)=E_n\psi_n(x)</span><script type="math/tex">H\psi_n(x)=E_n\psi_n(x)</script></span>, é dizer que <span><span class="MathJax_Preview">\{\psi_n(x)\}</span><script type="math/tex">\{\psi_n(x)\}</script></span> é o conjunto de autofunções do operador <span><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span>, representando os autoestados do sistema com autovalores <span><span class="MathJax_Preview">E_n</span><script type="math/tex">E_n</script></span>. Vimos nos exemplos discutidos, como no caso da caixa infinita, que <span><span class="MathJax_Preview">\psi_n(x)</span><script type="math/tex">\psi_n(x)</script></span> possui uma série de propriedades interessantes e úteis. Entre elas:</p>
<p>Dentro do que vimos até aqui, podemos, ainda de uma maneira informal, dizer que as soluções estacionárias <span><span class="MathJax_Preview">\psi_n(x)</span><script type="math/tex">\psi_n(x)</script></span> da EqS são funções de ondas que representam os possíveis estados do sistema, com energia <span><span class="MathJax_Preview">E_n</span><script type="math/tex">E_n</script></span>. Outra forma de dizer isso, observando a forma da equação <span><span class="MathJax_Preview">H\psi_n(x)=E_n\psi_n(x)</span><script type="math/tex">H\psi_n(x)=E_n\psi_n(x)</script></span>, é dizer que <span><span class="MathJax_Preview">\{\psi_n(x)\}</span><script type="math/tex">\{\psi_n(x)\}</script></span> é o conjunto de autofunções do operador <span><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span>, representando os autoestados do sistema com autovalores <span><span class="MathJax_Preview">E_n</span><script type="math/tex">E_n</script></span>. Vimos nos exemplos discutidos, como no caso da caixa infinita, que <span><span class="MathJax_Preview">\psi_n(x)</span><script type="math/tex">\psi_n(x)</script></span> possui uma série de propriedades interessantes e úteis. Entre elas: </p>
<blockquote>
<p><span><span class="MathJax_Preview">\int \psi^*_n(x)\psi_m(x)dx=\delta_{nm}</span><script type="math/tex">\int \psi^*_n(x)\psi_m(x)dx=\delta_{nm}</script></span></p>
<p><span><span class="MathJax_Preview">\Psi(x)=\sum_n c_n \psi_n(x)</span><script type="math/tex">\Psi(x)=\sum_n c_n \psi_n(x)</script></span>  </p>
<p><span><span class="MathJax_Preview">c_n = \int \psi^*_n(x) \Psi(x)dx</span><script type="math/tex">c_n = \int \psi^*_n(x) \Psi(x)dx</script></span> ; onde <span><span class="MathJax_Preview">\sum_n |c_n|^2 = 1</span><script type="math/tex">\sum_n |c_n|^2 = 1</script></span></p>
<p><span><span class="MathJax_Preview">&lt;A_{_{\Psi}}&gt; = \int \Psi^*(x) A \Psi(x) dx</span><script type="math/tex"><A_{_{\Psi}}> = \int \Psi^*(x) A \Psi(x) dx</script></span>  </p>
</blockquote>
<p>De fato, pode-se extender e generalizar essas ideias para expressar esses objetos em termos mais abstratos e gerais, através do conceito de espaço vetorial linear. Como os estados <span><span class="MathJax_Preview">\psi_n(x)</span><script type="math/tex">\psi_n(x)</script></span> e os operadores (que nesse contexto serão transformações lineares) nesses estados devem  satisfazer um certas propriedades para representar um sistema físico,  esses espaços vetoriais devem ter conjunto de estruturas e propriedades  especiais que veremos logo mais. Por simplicidade, iremos nos referir a esses espaços como <em>espaços de Hilbert</em>.</p>
<p>Para deixar esse ponto mais claro, vamos relembrar/introduzir algumas definições e conceitos, para formalizar e definir melhor essa ideia.</p>
<h2 id="52-espaco-vetorial-linear">5.2 Espaço vetorial linear</h2>
<p>Partido da definição mais geral e abstrata:</p>
<p><strong>Definição 1</strong></p>
<blockquote>
<p>Grupo comutativo sob adição, <span><span class="MathJax_Preview">\mathcal{V}</span><script type="math/tex">\mathcal{V}</script></span>, com multiplicação por escalar definida sobre um campo complexo <span><span class="MathJax_Preview">\mathcal{F}</span><script type="math/tex">\mathcal{F}</script></span>, satisfazendo propriedades associativa e distributiva. Os elementos do espaço <span><span class="MathJax_Preview">\mathcal{V}</span><script type="math/tex">\mathcal{V}</script></span> são chamados de <em>vetores</em> e os elementos do campo <span><span class="MathJax_Preview">\mathcal{F}</span><script type="math/tex">\mathcal{F}</script></span> são <em>escalares</em>.</p>
</blockquote>
<p>As propriedades associativa e distributiva da multiplicação por escalar implica:</p>
<p>Se <span><span class="MathJax_Preview">\mathcal{V}=\{\vec{u},\vec{v},\vec{w},...\}</span><script type="math/tex">\mathcal{V}=\{\vec{u},\vec{v},\vec{w},...\}</script></span> e <span><span class="MathJax_Preview">\mathcal{F}=\{\lambda,\mu,\kappa,...\}</span><script type="math/tex">\mathcal{F}=\{\lambda,\mu,\kappa,...\}</script></span>, temos que: <span><span class="MathJax_Preview">\lambda(\mu\vec{v})=(\lambda\mu)\vec{v}</span><script type="math/tex">\lambda(\mu\vec{v})=(\lambda\mu)\vec{v}</script></span>,<br />
<span><span class="MathJax_Preview">\lambda(\vec{v}+\vec{u})=\lambda\vec{v}+\lambda\vec{u}</span><script type="math/tex">\lambda(\vec{v}+\vec{u})=\lambda\vec{v}+\lambda\vec{u}</script></span> e  <span><span class="MathJax_Preview">(\lambda+\mu)\vec{u}=\lambda\vec{u}+\mu\vec{u}</span><script type="math/tex">(\lambda+\mu)\vec{u}=\lambda\vec{u}+\mu\vec{u}</script></span>. </p>
<p>Vale lembrar algumas outras definições (<em>Grupo</em> e <em>Campo</em>), da Algebra:</p>
<blockquote>
<p><strong>Grupo:</strong> Conjunto de elementos, que inclui inversos e identidade, com uma operação (<span><span class="MathJax_Preview">*</span><script type="math/tex">*</script></span>) fechada que satisfaz associatividade. Grupos não precisam ser comutativos, mas quando apresentam essa propriedade são chamados de grupos comutativos ou Abelianos.</p>
<blockquote>
<ol>
<li><em>Fechado</em>: <span><span class="MathJax_Preview">\forall\, x,y \in G \rightarrow x*y \in G</span><script type="math/tex">\forall\, x,y \in G \rightarrow x*y \in G</script></span></li>
<li><em>Associativo</em>: <span><span class="MathJax_Preview">\forall\, x,y,z \in G \rightarrow (x*y)*z=x*(y*z)</span><script type="math/tex">\forall\, x,y,z \in G \rightarrow (x*y)*z=x*(y*z)</script></span></li>
<li><em>Identidade</em>: <span><span class="MathJax_Preview">\exists\, e\in G \rightarrow e*x=x*e=x; \,\, \forall\, x \in G</span><script type="math/tex">\exists\, e\in G \rightarrow e*x=x*e=x; \,\, \forall\, x \in G</script></span></li>
<li><em>Inverso</em>: <span><span class="MathJax_Preview">\forall\, x \in G, \exists\, x^{-1} \rightarrow (x^{-1})*x=x*(x^{-1})=e</span><script type="math/tex">\forall\, x \in G, \exists\, x^{-1} \rightarrow (x^{-1})*x=x*(x^{-1})=e</script></span></li>
</ol>
</blockquote>
<p><strong>Campo:</strong> De maneira simples, são conjuntos de elementos onde são definidas as quatro operações aritméticas (<span><span class="MathJax_Preview">+</span><script type="math/tex">+</script></span>,<span><span class="MathJax_Preview">-</span><script type="math/tex">-</script></span>,<span><span class="MathJax_Preview">\times</span><script type="math/tex">\times</script></span>,<span><span class="MathJax_Preview">\div</span><script type="math/tex">\div</script></span>) de forma comutativa. Como as operações (<span><span class="MathJax_Preview">-</span><script type="math/tex">-</script></span>, <span><span class="MathJax_Preview">\div</span><script type="math/tex">\div</script></span>) são, na verdade, operações inversas de (<span><span class="MathJax_Preview">+</span><script type="math/tex">+</script></span>,<span><span class="MathJax_Preview">\times</span><script type="math/tex">\times</script></span>), são definidos em termos dessas duas operações. </p>
<blockquote>
<p>Formalmente, campos são conjuntos de elementos com operações de adição e multiplicação (<span><span class="MathJax_Preview">+</span><script type="math/tex">+</script></span>,<span><span class="MathJax_Preview">\times</span><script type="math/tex">\times</script></span>) definida; sendo comutativo para (<span><span class="MathJax_Preview">+</span><script type="math/tex">+</script></span>) e comutativo para (<span><span class="MathJax_Preview">\times</span><script type="math/tex">\times</script></span>) omitindo o elemento nulo (zero). Satisfaz ainda a propriedade distributiva <span><span class="MathJax_Preview">a\times(b+c)=a\times b + a\times c</span><script type="math/tex">a\times(b+c)=a\times b + a\times c</script></span>.</p>
</blockquote>
<p>Campos são, portanto, dois grupos comutativos com duas operações (<span><span class="MathJax_Preview">+</span><script type="math/tex">+</script></span>,<span><span class="MathJax_Preview">\times</span><script type="math/tex">\times</script></span>). Exemplos importantes são os campos dos números reais, complexos e racionais. </p>
</blockquote>
<p>Alternativamente, uma definição um pouco mais familiar de <strong>espaço vetorial</strong> é:</p>
<p><strong>Definição 2:</strong></p>
<blockquote>
<p>Conjunto <span><span class="MathJax_Preview">\mathcal{V}\ne\emptyset</span><script type="math/tex">\mathcal{V}\ne\emptyset</script></span> (não vazio) de elementos, chamados vetores, que é fechado sob adição e multiplicação por um escalar de um campo complexo <span><span class="MathJax_Preview">\mathcal{F}</span><script type="math/tex">\mathcal{F}</script></span>.</p>
</blockquote>
<p>Ou seja, se <span><span class="MathJax_Preview">\mathcal{V}=\{\vec{u},\vec{v},\vec{w},...\}</span><script type="math/tex">\mathcal{V}=\{\vec{u},\vec{v},\vec{w},...\}</script></span> e <span><span class="MathJax_Preview">\mathcal{F}=\{\lambda,\mu,\kappa,...\}</span><script type="math/tex">\mathcal{F}=\{\lambda,\mu,\kappa,...\}</script></span>, temos que:
<span><span class="MathJax_Preview">\forall\, \vec{u},\vec{w}\in \mathcal{V}</span><script type="math/tex">\forall\, \vec{u},\vec{w}\in \mathcal{V}</script></span> e <span><span class="MathJax_Preview">\forall\, \lambda,\mu \in \mathcal{F} \rightarrow \lambda\vec{u}+\mu\vec{w} \in \mathcal{V}</span><script type="math/tex">\forall\, \lambda,\mu \in \mathcal{F} \rightarrow \lambda\vec{u}+\mu\vec{w} \in \mathcal{V}</script></span> </p>
<p>Se o campo <span><span class="MathJax_Preview">\mathcal{F}</span><script type="math/tex">\mathcal{F}</script></span> é complexo (real) o espaço é dito ser um espaço vetorial linear complexo (real). </p>
<h3 id="dimensao-do-espaco">Dimensão do espaço</h3>
<p>Um conjunto de vetores <span><span class="MathJax_Preview">\{\phi_n \}</span><script type="math/tex">\{\phi_n \}</script></span> é dito linearmente independente (LI) se não há nenhuma combinação linear não-trivial que leve ao vetor nulo, isto é:  <span><span class="MathJax_Preview">\sum_n c_n \phi_n = 0 \rightarrow c_n = 0\, \forall\, n</span><script type="math/tex">\sum_n c_n \phi_n = 0 \rightarrow c_n = 0\, \forall\, n</script></span>. A dimensão <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> do espaço vetorial é dada pelo número máximo de vetores LI desse espaço. Qualquer vetor do espaço pode ser escrito como uma combinação linear dos vetores da base desse espaço, formado por vetores LI do espaço. Como veremos adiante, os espaçcos de Hilbert da MQ podem ser infinitos.</p>
<h2 id="53-espacos-de-hilbert-espacos-vetoriais-da-mq">5.3 Espaços de Hilbert: espaços vetoriais da MQ</h2>
<p>Na mecânica quântica são usados espaços vetoriais com algumas propriedades e estruturas adicionais, para garantir certas propriedades físicas desejáveis da teoria. É comum, principalmente entre os físicos, chamar esses estados de estados de Hilbert. Os espaços de Hilbert podem ser finitos (com dimensão <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>) ou infinitos, por exemplo, quando os vetores são funções contínuas. </p>
<p>Embora essa terminologia não seja muito precisa, dado que os
espaços vetoriais usados na MQ são apenas um tipo particular de espaço de Hilbert (neste contexto: os espaços cujos vetores são funções <em>quadrado-integráveis</em>, também chamados de espaços de Lebesgue do tipo <span><span class="MathJax_Preview">L_2</span><script type="math/tex">L_2</script></span>), nós usaremos essa "convenção", para simplificar a linguagem.</p>
<h3 id="produto-interno">Produto interno</h3>
<p>Uma das estruturas adicionais dos espaços de Hilbert é o produto interno que leva dois vetores do espaço num número complexo, segundo a definição:</p>
<div>
<div class="MathJax_Preview">\forall\, \phi, \psi \in \mathcal{H} \rightarrow (\phi,\psi) = \int \phi^*(x)\psi(x)\,dx</div>
<script type="math/tex; mode=display">\forall\, \phi, \psi \in \mathcal{H} \rightarrow (\phi,\psi) = \int \phi^*(x)\psi(x)\,dx</script>
</div>
<p>No caso de um espaço discreto de dimensão <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>, o produto interno é definido como </p>
<div>
<div class="MathJax_Preview">(w,v)=\sum_{i=1}^{d} w_i^* v_i</div>
<script type="math/tex; mode=display">(w,v)=\sum_{i=1}^{d} w_i^* v_i</script>
</div>
<p>Note que o produto interno resulta num escalar complexo, que não é um elemento do espaço de Hilbert. O produto interno tem as seguintes propriedades:</p>
<blockquote>
<p><span><span class="MathJax_Preview">(\phi,\psi) = \lambda \in \mathbb{C}</span><script type="math/tex">(\phi,\psi) = \lambda \in \mathbb{C}</script></span> (número complexo)</p>
<p><span><span class="MathJax_Preview">(\phi,\psi) = (\psi,\phi)^*</span><script type="math/tex">(\phi,\psi) = (\psi,\phi)^*</script></span></p>
<p><span><span class="MathJax_Preview">(\phi, c_1 \psi_1 + c_2 \psi_2 ) = c_1(\phi, \psi_1) + c_2(\phi,\psi_2 )</span><script type="math/tex">(\phi, c_1 \psi_1 + c_2 \psi_2 ) = c_1(\phi, \psi_1) + c_2(\phi,\psi_2 )</script></span></p>
<p><span><span class="MathJax_Preview">(c_1 \psi_1 + c_2 \psi_2, \phi ) = c_1^* (\psi_1, \phi) + c_2^*(\psi_2, \phi)</span><script type="math/tex">(c_1 \psi_1 + c_2 \psi_2, \phi ) = c_1^* (\psi_1, \phi) + c_2^*(\psi_2, \phi)</script></span></p>
<p><span><span class="MathJax_Preview">(\phi,\phi) \ge 0</span><script type="math/tex">(\phi,\phi) \ge 0</script></span>, sendo nulo apenas quando <span><span class="MathJax_Preview">\phi=0</span><script type="math/tex">\phi=0</script></span></p>
</blockquote>
<h3 id="comprimentos-e-angulos">Comprimentos e ângulos</h3>
<p>O conceito de produto interno nos permite generalizar os conceitos de  comprimento (norma) e medidas de ângulos entre vetores em espaços de dimensões e elementos arbitrários. Embora os vetores agora não sejam mais "setas" no espaço tridimensional Euclidiano, pode-se explorar a analogia com o conceito de produto escalar (o produto interno) daquele espaço, para definir a norma do vetor, através do produto interno de um vetor por ele mesmo: </p>
<div>
<div class="MathJax_Preview">(\phi,\phi) = \int \phi^*(x)\phi(x)\,dx = |\phi|^2</div>
<script type="math/tex; mode=display">(\phi,\phi) = \int \phi^*(x)\phi(x)\,dx = |\phi|^2</script>
</div>
<div>
<div class="MathJax_Preview">(v,v) = \sum_{i=1}^{d} v^*_i v_i = |v|^2</div>
<script type="math/tex; mode=display">(v,v) = \sum_{i=1}^{d} v^*_i v_i = |v|^2</script>
</div>
<div>
<div class="MathJax_Preview">||\phi|| = \sqrt{|\phi|^2}</div>
<script type="math/tex; mode=display">||\phi|| = \sqrt{|\phi|^2}</script>
</div>
<div>
<div class="MathJax_Preview">||v|| = \sqrt{|v|^2}</div>
<script type="math/tex; mode=display">||v|| = \sqrt{|v|^2}</script>
</div>
<p>Observe que a norma é sempre um número real, tal que <span><span class="MathJax_Preview">||\phi|| \ge 0</span><script type="math/tex">||\phi|| \ge 0</script></span> e <span><span class="MathJax_Preview">||v|| \ge 0</span><script type="math/tex">||v|| \ge 0</script></span>, conforme nos assegura a desigualdade de Schwartz:</p>
<div>
<div class="MathJax_Preview"> |(\psi,\phi)|^2 \le (\psi,\psi)(\phi,\phi).</div>
<script type="math/tex; mode=display"> |(\psi,\phi)|^2 \le (\psi,\psi)(\phi,\phi).</script>
</div>
<p>Também é satisfeito o teorema de desigualdade triangular:</p>
<div>
<div class="MathJax_Preview"> ||(\psi + \phi)|| \le ||\psi|| + ||\phi|| .</div>
<script type="math/tex; mode=display"> ||(\psi + \phi)|| \le ||\psi|| + ||\phi|| .</script>
</div>
<p>Para ambos os casos, a desigualdade só é válida quando um dos vetores é múltiplo do outro.</p>
<p>Dois veltores são tido ortogonais quando seu produto interno é nulo. Da mesma forma, um conjunto de vetores <span><span class="MathJax_Preview">\{\phi_n\}</span><script type="math/tex">\{\phi_n\}</script></span> é dito <em>ortonormal</em> quando o produto interno entre pares de seus elementos obedece a relação <span><span class="MathJax_Preview">(\phi_n,\phi_m)=\delta_{nm}</span><script type="math/tex">(\phi_n,\phi_m)=\delta_{nm}</script></span>.</p>
<h3 id="expansao-de-vetores">Expansão de vetores</h3>
<p>No caso em que <span><span class="MathJax_Preview">\mathcal{H}</span><script type="math/tex">\mathcal{H}</script></span> é finito, com dimensão <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>, dado um vetor arbitrário <span><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span> e uma base <span><span class="MathJax_Preview">\{ \phi_n \}</span><script type="math/tex">\{ \phi_n \}</script></span> de vetores linearmente independentes, podemos expressar o vetor <span><span class="MathJax_Preview">\psi = \sum_n c_n \phi_n</span><script type="math/tex">\psi = \sum_n c_n \phi_n</script></span>, onde <span><span class="MathJax_Preview">c_n=(\phi_n,\psi)</span><script type="math/tex">c_n=(\phi_n,\psi)</script></span> e <span><span class="MathJax_Preview">(\phi_n,\phi_m)=\delta_{nm}</span><script type="math/tex">(\phi_n,\phi_m)=\delta_{nm}</script></span>. Podemos pensar nos coeficientes <span><span class="MathJax_Preview">c_n</span><script type="math/tex">c_n</script></span> como sendo as componentes do vetor no espaço de Hilbert, análogos às componentes de um vetor no espaço Euclidiano. Porém, é importante lembrar que essas componentes são expressas por números complexos. As componente do vetor de estado têm toda a informação relativa ao estado, determinando completamente o vetor (estado) do sistema.</p>
<p>Também de modo análogo, podemos expressar as soma de dois vetore em termos dessas componentes </p>
<div>
<div class="MathJax_Preview">\Psi_a + \Psi_b = \sum_n (a_i + b_n) \psi_n.</div>
<script type="math/tex; mode=display">\Psi_a + \Psi_b = \sum_n (a_i + b_n) \psi_n.</script>
</div>
<div>
<div class="MathJax_Preview">\lambda \Psi_a= \sum_n \lambda a_i \psi_n.</div>
<script type="math/tex; mode=display">\lambda \Psi_a= \sum_n \lambda a_i \psi_n.</script>
</div>
<div class="admonition info">
<p class="admonition-title">Pare, Pense &amp; Contemple!</p>
<p>Antes de prosseguir, pare e reflita por um momento no significado e amplitude esses resultados. Lembre-se que o espaço <span><span class="MathJax_Preview">\mathcal{H}</span><script type="math/tex">\mathcal{H}</script></span> pode ter dimensõe infinitas, tanto no número de elemento (vetores), como nas dimensões (número de componentes) desses vetores. Esses resultados, nada óbvios, são extremamente poderosos e úteis, justificando plenamente o tempo investido em generalizar e abstrair a descrição dos nossos problemas usando esse formalismo.  </p>
</div>
<h2 id="54-notacao-de-dirac">5.4 Notação de Dirac</h2>
<p>Introduzimos agora a notação de Dirac, bastante popular na mecânica quântica, onde o vetor de estado é chamado de "<em>ket</em>" e representado pelo símbolo <span><span class="MathJax_Preview">|\psi\rangle</span><script type="math/tex">|\psi\rangle</script></span>. O vetor correspondente do <em>espaço dual</em> é chamado de "<em>bra</em>" é representado por <span><span class="MathJax_Preview">\langle\psi|</span><script type="math/tex">\langle\psi|</script></span>, de tal forma que o produto interno pode ser representado por <span><span class="MathJax_Preview">(\psi,\psi)=\langle\psi|\psi\rangle</span><script type="math/tex">(\psi,\psi)=\langle\psi|\psi\rangle</script></span>. </p>
<p>Note que <span><span class="MathJax_Preview">\langle\psi|=|\psi\rangle^*</span><script type="math/tex">\langle\psi|=|\psi\rangle^*</script></span>, corresponde ao complexo conjugado transposto do vetor de estado <span><span class="MathJax_Preview">|\psi\rangle</span><script type="math/tex">|\psi\rangle</script></span>. Isso fica claro, quando observamos a representação matricial desse vetores. Considere, por exemplo, que o vetor de estado tenha <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> componentes (<span><span class="MathJax_Preview">c_1,c_2,...,c_n</span><script type="math/tex">c_1,c_2,...,c_n</script></span>). Neste caso, o "<em>ket</em>" <span><span class="MathJax_Preview">|\psi\rangle</span><script type="math/tex">|\psi\rangle</script></span> é escrito como um vetor coluna, enquanto o seu vetor dual "<em>bra</em>" é um vetor linha, conforme indicado abaixo:</p>
<div>
<div class="MathJax_Preview">|\psi\rangle = 
\left[ 
\begin{array}{c} c_1\\ c_2\\ ...\\ c_n 
\end{array} 
\right] \, 
\Rightarrow \,\,\,
\langle\psi| =
\left[ 
\begin{array}{c} c_{1}^{*} &amp; c^*_2 &amp; ...&amp; c^*_n 
\end{array} 
\right].</div>
<script type="math/tex; mode=display">|\psi\rangle = 
\left[ 
\begin{array}{c} c_1\\ c_2\\ ...\\ c_n 
\end{array} 
\right] \, 
\Rightarrow \,\,\,
\langle\psi| =
\left[ 
\begin{array}{c} c_{1}^{*} & c^*_2 & ...& c^*_n 
\end{array} 
\right].</script>
</div>
<p>Nesta representação, todas as propriedades anteriores são equivalentes a operações sobre matrizes (ou vetores linha/coluna), como, por exemplo, soma (subtração), multiplicação por escalares e combinações lineares dessas operações. O produto interno (<em>"bracket"</em>), como é fácil perceber, corresponde a uma multiplicação de matrizes, resultando num escalar:</p>
<div>
<div class="MathJax_Preview">\langle\phi|\psi\rangle = 
\left[ \begin{array}{l} b^*_1 &amp; b^*_2 &amp; ... &amp; b^*_n \end{array} \right]
\left[ \begin{array}{c} c_1 \\ c_2 \\ ... \\ c_n \end{array} \right] 
= \begin{array}{l} b^*_1\,c_1 &amp; b^*_2\,c_2 &amp; ...&amp; b^*_n\,c_n \end{array}
= \sum_{k=1}^n b^*_k\,c_k.</div>
<script type="math/tex; mode=display">\langle\phi|\psi\rangle = 
\left[ \begin{array}{l} b^*_1 & b^*_2 & ... & b^*_n \end{array} \right]
\left[ \begin{array}{c} c_1 \\ c_2 \\ ... \\ c_n \end{array} \right] 
= \begin{array}{l} b^*_1\,c_1 & b^*_2\,c_2 & ...& b^*_n\,c_n \end{array}
= \sum_{k=1}^n b^*_k\,c_k.</script>
</div>
<h3 id="propriedades-do-produto-interno">Propriedades do produto interno</h3>
<p>Reescrevemos aqui as propriedade dos produto interno, na notação de Dirac. Para os vetores <span><span class="MathJax_Preview">|\psi\rangle</span><script type="math/tex">|\psi\rangle</script></span> e <span><span class="MathJax_Preview">|\phi\rangle</span><script type="math/tex">|\phi\rangle</script></span>, pertencentes ao espaço <span><span class="MathJax_Preview">\mathcal{H}</span><script type="math/tex">\mathcal{H}</script></span>, e os escalares <span><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> e <span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span> do campo complexo <span><span class="MathJax_Preview">\mathcal{F}</span><script type="math/tex">\mathcal{F}</script></span>, as seguintes propriedades são satisfeitas:</p>
<div>
<div class="MathJax_Preview">\begin{array}{ll}
1.\, &amp;\langle\psi|\phi\rangle = \langle\phi|\psi\rangle ^* \\
2.\, &amp;\langle\psi|(\alpha|\phi\rangle+\beta|\eta\rangle) = 
  \alpha\langle\psi|\phi\rangle + \beta\langle\psi|\eta\rangle \\
3.\, &amp;(\alpha\langle\phi| +\beta\langle\eta|)|\psi\rangle = 
  \alpha^*\langle\phi|\psi\rangle + \beta^*\langle\eta|\psi\rangle \\
4.\, &amp;\langle\psi|\psi\rangle \ge 0 \textrm{   sendo igual só se } 
|\psi \rangle = 0 \end{array}</div>
<script type="math/tex; mode=display">\begin{array}{ll}
1.\, &\langle\psi|\phi\rangle = \langle\phi|\psi\rangle ^* \\
2.\, &\langle\psi|(\alpha|\phi\rangle+\beta|\eta\rangle) = 
  \alpha\langle\psi|\phi\rangle + \beta\langle\psi|\eta\rangle \\
3.\, &(\alpha\langle\phi| +\beta\langle\eta|)|\psi\rangle = 
  \alpha^*\langle\phi|\psi\rangle + \beta^*\langle\eta|\psi\rangle \\
4.\, &\langle\psi|\psi\rangle \ge 0 \textrm{   sendo igual só se } 
|\psi \rangle = 0 \end{array}</script>
</div>
<p>Se <span><span class="MathJax_Preview">\langle\psi|\Phi\rangle=0</span><script type="math/tex">\langle\psi|\Phi\rangle=0</script></span>, os vetores são ortogonais. Os comprimentos (normas) dos vetores são expressos por:</p>
<p><strong>Norma do vetor</strong>:</p>
<div>
<div class="MathJax_Preview">||\psi|| = \sqrt{\langle\psi|\psi\rangle}.</div>
<script type="math/tex; mode=display">||\psi|| = \sqrt{\langle\psi|\psi\rangle}.</script>
</div>
<p><strong>Vetor normalizado</strong> quando:</p>
<div>
<div class="MathJax_Preview">||\psi|| = \sqrt{\langle\psi|\psi\rangle}=1.</div>
<script type="math/tex; mode=display">||\psi|| = \sqrt{\langle\psi|\psi\rangle}=1.</script>
</div>
<p><strong>Vetores ortonormais</strong>:</p>
<div>
<div class="MathJax_Preview">\langle u_j | u_k \rangle = \delta_{jk}</div>
<script type="math/tex; mode=display">\langle u_j | u_k \rangle = \delta_{jk}</script>
</div>
<div>
<div class="MathJax_Preview"> \delta_{jk} = \left\{ \begin{array}{c} 1 &amp; \textrm{ se }j=k \\ 0 &amp; \textrm{ caso contrário}\end{array}  \right. </div>
<script type="math/tex; mode=display"> \delta_{jk} = \left\{ \begin{array}{c} 1 & \textrm{ se }j=k \\ 0 & \textrm{ caso contrário}\end{array}  \right. </script>
</div>
<h2 id="55-vetores-de-base">5.5 Vetores de base</h2>
<p>O conjunto de vetore <span><span class="MathJax_Preview">\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}</span><script type="math/tex">\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}</script></span> formam uma base do espaço se eles satisfazem os seguinte critérios:</p>
<div class="admonition note">
<ol>
<li>É possível escrever qualquer vetor do espaço como uma combinação linear única dos vetores <span><span class="MathJax_Preview">\{ \phi_i \}</span><script type="math/tex">\{ \phi_i \}</script></span>. </li>
<li>O conjunto <span><span class="MathJax_Preview">\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}</span><script type="math/tex">\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}</script></span> é linearmente indenpendente.</li>
<li>Satisfaz a relação de completeza.</li>
</ol>
</div>
<p><strong>Condição 1:</strong>
Se o conjunto <span><span class="MathJax_Preview">\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}</span><script type="math/tex">\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}</script></span> estende todo o espaço <span><span class="MathJax_Preview">\mathcal{H}</span><script type="math/tex">\mathcal{H}</script></span>, é possível escrever um vetor <span><span class="MathJax_Preview">|\Psi\rangle</span><script type="math/tex">|\Psi\rangle</script></span> arbitrário como uma combinção linear dos vetores da base</p>
<div>
<div class="MathJax_Preview"> |\Psi\rangle = c_1 |\phi_1\rangle + c_2 |\phi_2\rangle + \dots + c_n |\phi_n\rangle = \sum_{i=1}^n c_i |\phi_i\rangle</div>
<script type="math/tex; mode=display"> |\Psi\rangle = c_1 |\phi_1\rangle + c_2 |\phi_2\rangle + \dots + c_n |\phi_n\rangle = \sum_{i=1}^n c_i |\phi_i\rangle</script>
</div>
<p>onde os coeficientes da expansão são números complexos dados por</p>
<div>
<div class="MathJax_Preview"> c_i = \langle \phi_i | \Psi \rangle.</div>
<script type="math/tex; mode=display"> c_i = \langle \phi_i | \Psi \rangle.</script>
</div>
<p><strong>Condição 2:</strong> 
A conjunto <span><span class="MathJax_Preview">\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}</span><script type="math/tex">\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}</script></span> é dito linearmente independente quando a equação </p>
<div>
<div class="MathJax_Preview"> a_1 |\phi_1\rangle + a_2 |\phi_2\rangle + \dots + a_n |\phi_n\rangle = 0</div>
<script type="math/tex; mode=display"> a_1 |\phi_1\rangle + a_2 |\phi_2\rangle + \dots + a_n |\phi_n\rangle = 0</script>
</div>
<p>implica que todos os coeficientes são nulos, <span><span class="MathJax_Preview">c_1=c_2=...=c_n=0</span><script type="math/tex">c_1=c_2=...=c_n=0</script></span>. Em outras palavras, não há nenhuma combinação (não trivial) que produza o vetor nulo.</p>
<blockquote>
<p><strong>Dimensão do espaço</strong>
O número de vetores da base fornece a dimensão do espaço vetorial.</p>
</blockquote>
<p><strong>Condição 3:</strong>
Um conjunto ortonormal <span><span class="MathJax_Preview">\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}</span><script type="math/tex">\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}</script></span> constitue uma base se e somente se satisfaz a <strong>relação de completeza</strong></p>
<div>
<div class="MathJax_Preview"> \sum_{i=1}^n |\phi_i\rangle \langle \phi_i| = 1 </div>
<script type="math/tex; mode=display"> \sum_{i=1}^n |\phi_i\rangle \langle \phi_i| = 1 </script>
</div>
<h3 id="procedimento-de-gram-schmidt">Procedimento de Gram-Schmidt</h3>
<p>Se tivermos um conjunto de vetores <span><span class="MathJax_Preview">\{ |u_i\rangle \}</span><script type="math/tex">\{ |u_i\rangle \}</script></span> que não é ortonormal, é possível usar o procedimento de Gram-Schmidt para construir uma base ortonormal a partir desse conjunto inicial. Para simplificar o entendimento do processo, consideramos um exemplo com 3 vetores de base (num espaço de dimensção 3). </p>
<p>Começamos selecionando um dos vetores do conjunto <span><span class="MathJax_Preview">\{ |u_i\rangle \}</span><script type="math/tex">\{ |u_i\rangle \}</script></span> e  definindo o vetor:</p>
<div>
<div class="MathJax_Preview"> |w_1\rangle = |u_1\rangle  </div>
<script type="math/tex; mode=display"> |w_1\rangle = |u_1\rangle  </script>
</div>
<p>A partir disso, constroi-se sucessivamente os vetores seguintes da base subtraindo deles as componentes nas direções ortonais àquelas já construídas. Neste caso, por exemplo, as direções <span><span class="MathJax_Preview">|w_2\rangle</span><script type="math/tex">|w_2\rangle</script></span> e <span><span class="MathJax_Preview">|w_3\rangle</span><script type="math/tex">|w_3\rangle</script></span> são construídas subtraindo as componente na direção de <span><span class="MathJax_Preview">|w_1\rangle</span><script type="math/tex">|w_1\rangle</script></span> e <span><span class="MathJax_Preview">|w_2\rangle</span><script type="math/tex">|w_2\rangle</script></span>, conforme:</p>
<div>
<div class="MathJax_Preview">\begin{array}{c}
&amp;&amp;|w_2 \rangle =&amp; |u_2\rangle - \frac{\langle w_1 | u_2 \rangle}{\langle w_1 | w_1 \rangle} |w_1\rangle \\ \\
&amp;&amp;|w_3\rangle =&amp; |u_3\rangle - \frac{\langle w_1 | u_3 \rangle }{\langle w_1 | w_1 \rangle} |w_1\rangle - \frac{\langle w_2 | u_3 \rangle }{\langle w_2 | w_2 \rangle} |w_2\rangle \end{array}</div>
<script type="math/tex; mode=display">\begin{array}{c}
&&|w_2 \rangle =& |u_2\rangle - \frac{\langle w_1 | u_2 \rangle}{\langle w_1 | w_1 \rangle} |w_1\rangle \\ \\
&&|w_3\rangle =& |u_3\rangle - \frac{\langle w_1 | u_3 \rangle }{\langle w_1 | w_1 \rangle} |w_1\rangle - \frac{\langle w_2 | u_3 \rangle }{\langle w_2 | w_2 \rangle} |w_2\rangle \end{array}</script>
</div>
<p>Finalmente, para obter um conjunto ortonormal <span><span class="MathJax_Preview">\{ |v_i\rangle \}</span><script type="math/tex">\{ |v_i\rangle \}</script></span>, nós podemos normalizar cada um dos vetores <span><span class="MathJax_Preview">|w_i\rangle</span><script type="math/tex">|w_i\rangle</script></span>:</p>
<div>
<div class="MathJax_Preview">|v_1\rangle = \frac{ |w_1 \rangle }{||\langle w_1 | w_1 \rangle||}; \,
|v_2\rangle = \frac{ |w_2 \rangle }{||\langle w_2 | w_2 \rangle}||; \,
|v_3\rangle = \frac{ |w_3 \rangle }{||\langle w_3 | w_3 \rangle||}</div>
<script type="math/tex; mode=display">|v_1\rangle = \frac{ |w_1 \rangle }{||\langle w_1 | w_1 \rangle||}; \,
|v_2\rangle = \frac{ |w_2 \rangle }{||\langle w_2 | w_2 \rangle}||; \,
|v_3\rangle = \frac{ |w_3 \rangle }{||\langle w_3 | w_3 \rangle||}</script>
</div>
<p>De forma geral, para um cojunto finito de vetores <span><span class="MathJax_Preview">\{u_k\}</span><script type="math/tex">\{u_k\}</script></span>, de um espaço vetorial <span><span class="MathJax_Preview">\mathcal{U}</span><script type="math/tex">\mathcal{U}</script></span> de dimensão <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>, pode-se escrever os vetores ortonormais <span><span class="MathJax_Preview">\{v_k\}</span><script type="math/tex">\{v_k\}</script></span> através da construindo:</p>
<div>
<div class="MathJax_Preview">
\left|v_{k+1}\right\rangle \equiv \frac{\left|w_{k+1}\right\rangle-\sum_{i=1}^{k}\left\langle v_{i} | w_{k+1}\right\rangle\left|v_{i}\right\rangle}{\|\left|w_{k+1}\right\rangle-\sum_{i=1}^{k}\left\langle v_{i} | w_{k+1}\right\rangle\left|v_{i}\right\rangle \|}.
</div>
<script type="math/tex; mode=display">
\left|v_{k+1}\right\rangle \equiv \frac{\left|w_{k+1}\right\rangle-\sum_{i=1}^{k}\left\langle v_{i} | w_{k+1}\right\rangle\left|v_{i}\right\rangle}{\|\left|w_{k+1}\right\rangle-\sum_{i=1}^{k}\left\langle v_{i} | w_{k+1}\right\rangle\left|v_{i}\right\rangle \|}.
</script>
</div>
<h3 id="algebra-de-dirac">Algebra de Dirac</h3>
<p>Vejamos como expressar vetores inteiramente em termos do <em>kets</em> da base e manipular <em>bras</em> e <em>kets</em> de forma algébrica.</p>
<p><strong>Representando um <em>ket</em> como <em>bra</em></strong></p>
<p>Para obter o <em>bra</em> correspondente a um dado <em>ket</em>, <span><span class="MathJax_Preview">| \phi\rangle = \alpha |\psi\rangle</span><script type="math/tex">| \phi\rangle = \alpha |\psi\rangle</script></span>, basta tomar o complexo conjugado:</p>
<div>
<div class="MathJax_Preview">\langle \phi|  = (\alpha |\psi\rangle)^* = \alpha \langle \psi| </div>
<script type="math/tex; mode=display">\langle \phi|  = (\alpha |\psi\rangle)^* = \alpha \langle \psi| </script>
</div>
<p>podemos também escrever <span><span class="MathJax_Preview">|\alpha \psi\rangle = \alpha |\psi\rangle</span><script type="math/tex">|\alpha \psi\rangle = \alpha |\psi\rangle</script></span>. O mesmo pode ser feito para o <em>bra</em>, mas deve-se tomar um cuidado extra, neste caso: </p>
<div>
<div class="MathJax_Preview"> \langle \alpha \psi| = \alpha^* \langle \psi|</div>
<script type="math/tex; mode=display"> \langle \alpha \psi| = \alpha^* \langle \psi|</script>
</div>
<div class="admonition question">
<p class="admonition-title">Exercício sugerido</p>
<p>Suponha que <span><span class="MathJax_Preview">\{ |u_1 \rangle, |u_2 \rangle, |u_3 \rangle \}</span><script type="math/tex">\{ |u_1 \rangle, |u_2 \rangle, |u_3 \rangle \}</script></span> seja uma base ortonormal. Nesta base temos:</p>
<div>
<div class="MathJax_Preview"> | \psi \rangle = 2i |u_1 \rangle - 3|u_2 \rangle + i|u_3 \rangle </div>
<script type="math/tex; mode=display"> | \psi \rangle = 2i |u_1 \rangle - 3|u_2 \rangle + i|u_3 \rangle </script>
</div>
<div>
<div class="MathJax_Preview"> | \phi\rangle = 3 |u_1 \rangle - 2|u_2 \rangle + 4|u_3 \rangle </div>
<script type="math/tex; mode=display"> | \phi\rangle = 3 |u_1 \rangle - 2|u_2 \rangle + 4|u_3 \rangle </script>
</div>
<ul>
<li>a) Ache <span><span class="MathJax_Preview">\langle\psi|</span><script type="math/tex">\langle\psi|</script></span> e <span><span class="MathJax_Preview">\langle \phi|</span><script type="math/tex">\langle \phi|</script></span>.     </li>
<li>b) Calcule o produto interno <span><span class="MathJax_Preview">\langle \phi|\psi\rangle</span><script type="math/tex">\langle \phi|\psi\rangle</script></span> e mostre que igual seu conjugado.</li>
<li>c) Sendo <span><span class="MathJax_Preview">a = 3 + 3i</span><script type="math/tex">a = 3 + 3i</script></span>, calcule <span><span class="MathJax_Preview">|a\psi\rangle</span><script type="math/tex">|a\psi\rangle</script></span>. </li>
<li>d) Ache as expressões de <span><span class="MathJax_Preview">|\psi+\phi\rangle</span><script type="math/tex">|\psi+\phi\rangle</script></span> e  <span><span class="MathJax_Preview">|\psi-\phi\rangle</span><script type="math/tex">|\psi-\phi\rangle</script></span></li>
<li>e) Calcule <span><span class="MathJax_Preview">\langle a \psi |</span><script type="math/tex">\langle a \psi |</script></span> e compare com <span><span class="MathJax_Preview">a^* \langle \psi|</span><script type="math/tex">a^* \langle \psi|</script></span>.</li>
<li>f) Normalize o vetor  <span><span class="MathJax_Preview">| \psi \rangle</span><script type="math/tex">| \psi \rangle</script></span>.</li>
</ul>
</div>
<p><strong>Encontrando os coeficientes da expansão</strong></p>
<p>Da mesma forma que fazemos os vetores do espaço Euclidiano, para encontrar as componentes de um vetor no espaço de Hilber basta fazer o produto escalar (interno) do vetor com o correspondente verto da base. Em notação de Dirac, se o vetor é dado por 
$$
|\psi\rangle=c_{1}\left|u_{1}\right\rangle+c_{2}\left|u_{2}\right\rangle+\cdots+c_{n}\left|u_{n}\right\rangle=\sum_{i=1}^{n} c_{i}\left|u_{i}\right\rangle
$$<br />
os coeficientes são dados por
$$
c_i = \left\langle u_i | \psi \right\rangle
$$
que podem ser convenientemente escritos na forma</p>
<div>
<div class="MathJax_Preview">
| \psi \rangle \rightarrow\left( \begin{array}{c} \left\langle u_{1} | \psi\right\rangle \\ \left\langle u_{2} | \psi\right\rangle \\ \vdots \\ \left\langle u_{n} | \psi\right\rangle \end{array} \right) = 
\left(\begin{array}{c} c_{1} \\ c_{2} \\ \vdots \\ c_{n} \end{array}\right)
</div>
<script type="math/tex; mode=display">
| \psi \rangle \rightarrow\left( \begin{array}{c} \left\langle u_{1} | \psi\right\rangle \\ \left\langle u_{2} | \psi\right\rangle \\ \vdots \\ \left\langle u_{n} | \psi\right\rangle \end{array} \right) = 
\left(\begin{array}{c} c_{1} \\ c_{2} \\ \vdots \\ c_{n} \end{array}\right)
</script>
</div>
<p>Note, porém, que um vetor pode ser escrito em termos de diversas bases diferentes (o vetor tem existência indepentende da base) e em cada uma delas os valores das componentes serão diferentes.</p>
<div class="admonition example">
<p class="admonition-title">Exemplo</p>
<p>Considere o vetor abaixo, expresso em termos de uma base ortonormal:
$$ |\psi\rangle=2 i\left|u_{1}\right\rangle-3\left|u_{2}\right\rangle+i\left|u_{3}\right\rangle$$</p>
</div>
<p>Neste caso, o velor coluna dos coeficientes representando <span><span class="MathJax_Preview">|\psi\rangle</span><script type="math/tex">|\psi\rangle</script></span> é dado por</p>
<div>
<div class="MathJax_Preview">
|\psi\rangle = 
\left( \begin{array}{c} \left\langle u_{1} | \psi\right\rangle \\ \left\langle u_{2} | \psi\right\rangle \\ \left\langle u_{3} |\psi\right\rangle \end{array}\right) = 
\left( \begin{array}{c} 2 i \\ -3 \\ i \end{array} \right).
</div>
<script type="math/tex; mode=display">
|\psi\rangle = 
\left( \begin{array}{c} \left\langle u_{1} | \psi\right\rangle \\ \left\langle u_{2} | \psi\right\rangle \\ \left\langle u_{3} |\psi\right\rangle \end{array}\right) = 
\left( \begin{array}{c} 2 i \\ -3 \\ i \end{array} \right).
</script>
</div>
<p>Da mesma forma, o vetor dual ("<em>bra</em>") correspondente ao vetor <span><span class="MathJax_Preview">|\psi\rangle</span><script type="math/tex">|\psi\rangle</script></span> pode ser representado na forma de um vetor linha</p>
<div>
<div class="MathJax_Preview">
\left\langle\psi\left|=\left(\left\langle\psi | u_{1}\right\rangle\left\langle\psi | u_{2}\right\rangle\left\langle\psi | u_{3}\right\rangle\right)=\left(\left\langle u_{1} | \psi\right\rangle^{*}\left\langle u_{2} | \psi\right\rangle^{*}\left\langle u_{3} | \psi\right\rangle^{*}\right)\right.\right.
</div>
<script type="math/tex; mode=display">
\left\langle\psi\left|=\left(\left\langle\psi | u_{1}\right\rangle\left\langle\psi | u_{2}\right\rangle\left\langle\psi | u_{3}\right\rangle\right)=\left(\left\langle u_{1} | \psi\right\rangle^{*}\left\langle u_{2} | \psi\right\rangle^{*}\left\langle u_{3} | \psi\right\rangle^{*}\right)\right.\right.
</script>
</div>
<p>e portanto</p>
<div>
<div class="MathJax_Preview">
\langle\psi|=\left((2 i)^{*}(-3)^{*}(i)^{*}\right)=(-2 i-3-i).
</div>
<script type="math/tex; mode=display">
\langle\psi|=\left((2 i)^{*}(-3)^{*}(i)^{*}\right)=(-2 i-3-i).
</script>
</div>
<h2 id="56-operadores-lineares">5.6 Operadores lineares</h2>
<p>Grandezas físicas observáveis, que podem ser medidas no laboratório, como posição e momento, são representandos dentro da estrutura matemática da mecânica quântica por operadores lineares num espaço vetorial de Hilbert. Matematicamente, esses operadores são mapas que levam (transformam) um vetor em outro vetor. Isto é, são receitas ou regras de transformação de um dado vetor num novo vetor, geralmente diferente do primeiro. Frequentemente usa-se como símbolo uma letra maíscula com "chapel" (sinal circunflexo) sobre a letra para indicar um operador. Assim, na notação de Dirac, escreve-se, por exemplo:
$$
\hat{T}|\psi\rangle=|\phi \rangle.
$$</p>
<p>Os operadores que mais nos interessam na MQ são os operadores lineares. Um operador <span><span class="MathJax_Preview">\hat{T}:\mathcal{H}\rightarrow\mathcal{H}</span><script type="math/tex">\hat{T}:\mathcal{H}\rightarrow\mathcal{H}</script></span> é linear no espaço <span><span class="MathJax_Preview">\mathcal{H}</span><script type="math/tex">\mathcal{H}</script></span> se, dados escalares <span><span class="MathJax_Preview">\alpha, \beta \in \mathbb{C}</span><script type="math/tex">\alpha, \beta \in \mathbb{C}</script></span> e vetores <span><span class="MathJax_Preview">|u\rangle, |v\rangle \in \mathcal{H}</span><script type="math/tex">|u\rangle, |v\rangle \in \mathcal{H}</script></span>, ele satisfaz a relação:
$$
\hat{T}(\alpha|u\rangle+\beta|v\rangle)=\alpha\, \hat{T}|u\rangle+\beta\, \hat{T}|v\rangle.
$$ </p>
<p>Além disso, os operadores lineare também satisfazem as seguintes relações:</p>
<div>
<div class="MathJax_Preview">
(\hat{T}+\hat{S})\ket{u}=\hat{T}\ket{u} + \hat{S}\ket{u}
</div>
<script type="math/tex; mode=display">
(\hat{T}+\hat{S})\ket{u}=\hat{T}\ket{u} + \hat{S}\ket{u}
</script>
</div>
<div>
<div class="MathJax_Preview"> 
(\hat{T}\,\hat{S})\ket{u}=\hat{T}(\hat{S}\ket{u})
</div>
<script type="math/tex; mode=display"> 
(\hat{T}\,\hat{S})\ket{u}=\hat{T}(\hat{S}\ket{u})
</script>
</div>
<p>Operadores atuam tanto nos vetores <em>kets</em> como nos vetores duais <em>bras</em>, seguindo a seguinte notação (atenção para a ordem!):
$$ 
\hat{T}\ket{u} \quad \text{ ou } \quad \bra{u} \hat{T}
$$
mas nunca <span><span class="MathJax_Preview">(\,\ket{u} \hat{T}\,)</span><script type="math/tex">(\,\ket{u} \hat{T}\,)</script></span> ou <span><span class="MathJax_Preview">(\,\hat{T} \bra{u}\,)</span><script type="math/tex">(\,\hat{T} \bra{u}\,)</script></span>, que são formas incorretas (inválidas)!</p>
<h3 id="exemplos-importantes">Exemplos importantes</h3>
<ul>
<li>
<p><strong>Operador Identidade:</strong> o operador mais simples
$$
\mathbb{1}\ket{u}=\ket{u}
$$</p>
</li>
<li>
<p><strong>Produto externo (definição):</strong> o produto externo entre <em>kets</em> e <em>bras</em> é dado por
$$
\ket{\psi}\bra{\phi} = \hat{P}
$$
note que o produto externo resulta num operador e não num escalar! Essa construção será muito útil, como veremos adiante.</p>
</li>
<li>
<p><strong>Operador projetor:</strong> usando o produto externo, podemos calcular as projeções de um dado vetor numa base <span><span class="MathJax_Preview">\{ u_i \}</span><script type="math/tex">\{ u_i \}</script></span>, fazendo </p>
</li>
</ul>
<div>
<div class="MathJax_Preview">
\begin{array}{ll}
\hat{P}_{u_i} = | u_i \rangle \langle u_i |  &amp;\rightarrow \quad \hat{P}_{u_i} | \chi\rangle = | u_i \rangle (\langle u_i |\chi\rangle) = \beta | u_i \rangle \\
\hat{P}_{u} = \sum_i | u_i \rangle \langle u_i |  &amp;\rightarrow \quad  {P}_{u} | \chi\rangle = \sum_i \,c_i | u_i \rangle = | \chi\rangle
\end{array}
</div>
<script type="math/tex; mode=display">
\begin{array}{ll}
\hat{P}_{u_i} = | u_i \rangle \langle u_i |  &\rightarrow \quad \hat{P}_{u_i} | \chi\rangle = | u_i \rangle (\langle u_i |\chi\rangle) = \beta | u_i \rangle \\
\hat{P}_{u} = \sum_i | u_i \rangle \langle u_i |  &\rightarrow \quad  {P}_{u} | \chi\rangle = \sum_i \,c_i | u_i \rangle = | \chi\rangle
\end{array}
</script>
</div>
<ul>
<li><strong>Relação de completeza:</strong> usando os resultados anteriores podemos observar que</li>
</ul>
<div>
<div class="MathJax_Preview">
|\psi\rangle=\sum_{i=1}^{n}c_i\left|u_{i}\right\rangle = \sum_{i=1}^{n}\left|u_{i}\right\rangle\left\langle u_{i} | \psi\right\rangle=\left(\sum_{i=1}^{n}\left|u_{i}\right\rangle\left\langle u_{i}\right|\right)|\psi\rangle
</div>
<script type="math/tex; mode=display">
|\psi\rangle=\sum_{i=1}^{n}c_i\left|u_{i}\right\rangle = \sum_{i=1}^{n}\left|u_{i}\right\rangle\left\langle u_{i} | \psi\right\rangle=\left(\sum_{i=1}^{n}\left|u_{i}\right\rangle\left\langle u_{i}\right|\right)|\psi\rangle
</script>
</div>
<div>
<div class="MathJax_Preview">
\sum_{i=1}^{n}\left|u_{i}\right\rangle\left\langle u_{i}\right| = \mathbb{1}
</div>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}\left|u_{i}\right\rangle\left\langle u_{i}\right| = \mathbb{1}
</script>
</div>
<h3 id="representacao-de-operadores">Representação de operadores</h3>
<p>A operação matemática de transformar um vetor de um espaço vetorial linear num outro vetor, através da ação de um operador linear, pode ser representada de várias formas. Uma delas é a representação matricial, onde os operadores são representados por matrizes quadradas e os vetores por matrizes linhas e colunas. Neste caso, a transformação linear torna-se uma mera multiplicação dessas matrizes.</p>
<p>É importante lembrar que, da mesma forma que os vetores do espaço, os operadores têm existência e significado próprios no espaço vetorial e sua ação independe da representação ou da base escolhida. Por outro lado, sua representação matricial, em geral, depende da base escolhida. Devemos lembrar, porém, que a forma matricial é apenas uma das representações possíveis de um operador linear. </p>
<p><strong>Representação matricial</strong></p>
<p>A matriz de um operador numa dada base pode ser obtida a partir da ação do operador em cada vetor da base. Assim, se <span><span class="MathJax_Preview">\{ u_i \}</span><script type="math/tex">\{ u_i \}</script></span> representa o conjunto de vetores da base, as componentes do operador <span><span class="MathJax_Preview">\hat{T}</span><script type="math/tex">\hat{T}</script></span> podem ser obtidas através da operação</p>
<div>
<div class="MathJax_Preview">
T_{i j}=\left\langle u_{i}|\hat{T}| u_{j}\right\rangle.
</div>
<script type="math/tex; mode=display">
T_{i j}=\left\langle u_{i}|\hat{T}| u_{j}\right\rangle.
</script>
</div>
<p>Em um espaço vetorial de dimensão n, as componentes do operador podem ser arranjadas na forma de uma matriz quadrada <span><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span>, onde <span><span class="MathJax_Preview">T_{i j}</span><script type="math/tex">T_{i j}</script></span> representa o elemento na linha <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> e coluna <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>, conforme:</p>
<div>
<div class="MathJax_Preview">
\begin{aligned}
\hat{T} \rightarrow\left(T_{i j}\right) &amp;=\left(\begin{array}{cccc}
T_{11} &amp; T_{12} &amp; \dots &amp; T_{1 n} \\
T_{21} &amp; T_{22} &amp; \dots &amp; T_{2 n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
T_{n 1} &amp; T_{n 2} &amp; \dots &amp; T_{n n}
\end{array}\right) \\
&amp;=\left(\begin{array}{cccc}
\left\langle u_{1}|\hat{T}| u_{1}\right\rangle &amp; \left\langle u_{1}|\hat{T}| u_{2}\right\rangle &amp; \dots &amp; \left\langle u_{1}|\hat{T}| u_{n}\right\rangle \\
\left\langle u_{2} \hat{T} | u_{1}\right\rangle &amp; \left\langle u_{2}|\hat{T}| u_{2}\right\rangle &amp; \dots &amp; \left\langle u_{2}|\hat{T}| u_{n}\right\rangle \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\left\langle u_{n}|\hat{T}| u_{1}\right\rangle &amp; \left\langle u_{n}|\hat{T}| u_{2}\right\rangle &amp; \dots &amp; \left\langle u_{n}|\hat{T}| u_{n}\right\rangle
\end{array}\right)
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\hat{T} \rightarrow\left(T_{i j}\right) &=\left(\begin{array}{cccc}
T_{11} & T_{12} & \dots & T_{1 n} \\
T_{21} & T_{22} & \dots & T_{2 n} \\
\vdots & \vdots & \ddots & \vdots \\
T_{n 1} & T_{n 2} & \dots & T_{n n}
\end{array}\right) \\
&=\left(\begin{array}{cccc}
\left\langle u_{1}|\hat{T}| u_{1}\right\rangle & \left\langle u_{1}|\hat{T}| u_{2}\right\rangle & \dots & \left\langle u_{1}|\hat{T}| u_{n}\right\rangle \\
\left\langle u_{2} \hat{T} | u_{1}\right\rangle & \left\langle u_{2}|\hat{T}| u_{2}\right\rangle & \dots & \left\langle u_{2}|\hat{T}| u_{n}\right\rangle \\
\vdots & \vdots & \ddots & \vdots \\
\left\langle u_{n}|\hat{T}| u_{1}\right\rangle & \left\langle u_{n}|\hat{T}| u_{2}\right\rangle & \dots & \left\langle u_{n}|\hat{T}| u_{n}\right\rangle
\end{array}\right)
\end{aligned}
</script>
</div>
<div class="admonition question">
<p class="admonition-title">Exercício sugerido</p>
<p>Suponha uma base ortonormal <span><span class="MathJax_Preview">\left\{\left|u_{1}\right\rangle,\left|u_{2}\right\rangle,\left|u_{3}\right\rangle\right\}</span><script type="math/tex">\left\{\left|u_{1}\right\rangle,\left|u_{2}\right\rangle,\left|u_{3}\right\rangle\right\}</script></span>, um operador <span><span class="MathJax_Preview">\hat{A}</span><script type="math/tex">\hat{A}</script></span> cuja a ação é dada por:
$$
\begin{array}{l}
\hat{A}\left|u_{1}\right\rangle=2\left|u_{1}\right\rangle; \
\hat{A}\left|u_{2}\right\rangle=3\left|u_{1}\right\rangle-i\left|u_{3}\right\rangle; \
\hat{A}\left|u_{3}\right\rangle=-\left|u_{2}\right\rangle
\end{array}
$$
Escreve a matriz que representa o operador nesta base.</p>
</div>
<p><strong><em>Definição</em> : Traço de um operador</strong></p>
<p>O traço de um operador <span><span class="MathJax_Preview">\hat{T}</span><script type="math/tex">\hat{T}</script></span>, denotado por <span><span class="MathJax_Preview">\text{Tr}(\hat{T})</span><script type="math/tex">\text{Tr}(\hat{T})</script></span>, é definido como sendo a soma dos elementos na diagonal principal da matriz que o representa </p>
<div>
<div class="MathJax_Preview">
\text{Tr}(\hat{T})=T_{11}+T_{22}+\ldots+T_{n n}=\sum_{i=1}^{n} T_{i i}.
</div>
<script type="math/tex; mode=display">
\text{Tr}(\hat{T})=T_{11}+T_{22}+\ldots+T_{n n}=\sum_{i=1}^{n} T_{i i}.
</script>
</div>
<p>Alternativamente, o traço também pode ser escrito como:</p>
<div>
<div class="MathJax_Preview">
\text{Tr}(\hat{T})=\left\langle u_{1}|\hat{T}| u_{2}\right\rangle+\left\langle u_{2}|\hat{T}| u_{2}\right\rangle+\ldots+\left\langle u_{n}|\hat{T}| u_{n}\right\rangle=\sum_{i=1}^{n}\left\langle u_{i}|\hat{T}| u_{i}\right\rangle
</div>
<script type="math/tex; mode=display">
\text{Tr}(\hat{T})=\left\langle u_{1}|\hat{T}| u_{2}\right\rangle+\left\langle u_{2}|\hat{T}| u_{2}\right\rangle+\ldots+\left\langle u_{n}|\hat{T}| u_{n}\right\rangle=\sum_{i=1}^{n}\left\langle u_{i}|\hat{T}| u_{i}\right\rangle
</script>
</div>
<div class="admonition question">
<p class="admonition-title">Exercício sugerido</p>
<p>O traço de um operador obedece uma relação cíclica, como indicado
$$
\operatorname{Tr}(A B C)=\operatorname{Tr}(B C A)=\operatorname{Tr}(C A B)
$$
Prove isso para o caso de dois operadores <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> e <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>, i.e. prove que <span><span class="MathJax_Preview">\operatorname{Tr}(A B)=\operatorname{Tr}(B A)</span><script type="math/tex">\operatorname{Tr}(A B)=\operatorname{Tr}(B A)</script></span></p>
</div>
<h3 id="valores-esperados">Valores esperados</h3>
<p>O valore esperado de um operador com relação a um estado <span><span class="MathJax_Preview">\Psi</span><script type="math/tex">\Psi</script></span> é dado por</p>
<div>
<div class="MathJax_Preview">
\langle\hat{A}\rangle=\langle\Psi|\hat{A}| \Psi\rangle
</div>
<script type="math/tex; mode=display">
\langle\hat{A}\rangle=\langle\Psi|\hat{A}| \Psi\rangle
</script>
</div>
<div class="admonition question">
<p class="admonition-title">Exercício sugerido</p>
<p>Considere uma partícula no estado
$$
|\Psi\rangle=2 i\left|u_{1}\right\rangle-\left|u_{2}\right\rangle+4 i\left|u_{3}\right\rangle
$$
e um operador
$$
\hat{A}=\left|u_{1}\right\rangle\left\langle u_{1}| -2 i| u_{1}\right\rangle\left\langle u_{2}|+| u_{3}\right\rangle\left\langle u_{3}\right|
$$
Considerando que <span><span class="MathJax_Preview">\{ |u_i\rangle \}</span><script type="math/tex">\{ |u_i\rangle \}</script></span> é uma base ortonormal, calcule <span><span class="MathJax_Preview">\langle \hat{A} \rangle</span><script type="math/tex">\langle \hat{A} \rangle</script></span> nesse estado.</p>
</div>
<h3 id="autovalores-e-autovetores">Autovalores e autovetores</h3>
<p>Quando um operador age sobre um dado vetor (estado) e o resultado é o mesmo vetor (estado) multiplicado por um escalar, o vetor é chamado de autovetor (autoestado) e o escalar de autovalor. Assim, por exemplo, no caso da energia total
$$
\hat{H}|\psi_n\rangle = E_n |\psi_n \rangle
$$</p>
<p>No contexto da mecânica quântica, operadores de observáveis físicos têm como autovalores o conjunto de todas as possíveis medidas daquela grandeza física, num dado sistema quântico. Os autovetores de um operador são autoestados do sistema quântico e são muito importantes, pois esses autovetores formam uma base do espaço e permitem represetar qualquer estado do sistema. A seguir temos uma breve revisão de como calcular autovalores e autovetores, a partir de conceitos e métodos de Algebra Linear.</p>
<p><strong>Cálculo dos autovalores</strong></p>
<p>Dado um operador linear <span><span class="MathJax_Preview">\hat{T}</span><script type="math/tex">\hat{T}</script></span>, como já vimos, pode-se sempre representá-lo por uma matriz <span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>. O conjunto de autovalores <span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span> dessa matriz podem ser determinados através da <em>equação característica</em> (também chamada de <em>equação secular</em>), para o determinante abaixo:
$$
\operatorname{det}(T-\lambda I)=0$$
onde <span><span class="MathJax_Preview">I=\mathbb{1}</span><script type="math/tex">I=\mathbb{1}</script></span> é a matriz identidade. A solução da equação característica fornece os autovalores <span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>, que são as raizes do <em>polinônimo</em> (<em>característico</em>), indicado acima.</p>
<div class="admonition question">
<p class="admonition-title">Exercício sugerido</p>
<p>Escreva o equação característica e ache os autovalores da matriz</p>
<div>
<div class="MathJax_Preview">
A = 
\begin{pmatrix}
7i &amp; -1 \\ 
2 &amp; -6i
\end{pmatrix} 
</div>
<script type="math/tex; mode=display">
A = 
\begin{pmatrix}
7i & -1 \\ 
2 & -6i
\end{pmatrix} 
</script>
</div>
</div>
<p><strong>Cálculo dos autovetores</strong></p>
<p>A partir dos autovalores pode-se determinar os autovetores da matriz <span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>, que pode ser então escrita na forma diagonal. Para ilustrar melhor isso, usaremos um exemplo, a partir do problema proposto a seguir.</p>
<div class="admonition question">
<p class="admonition-title">Exercício sugerido</p>
<p>Considere o operador <span><span class="MathJax_Preview">\hat{T}=\ket{\phi_1}\bra{\phi_1}+2\ket{\phi_1}\bra{\phi_2}+\ket{\phi_2}\bra{\phi_1}</span><script type="math/tex">\hat{T}=\ket{\phi_1}\bra{\phi_1}+2\ket{\phi_1}\bra{\phi_2}+\ket{\phi_2}\bra{\phi_1}</script></span>, expresso numa base ortonormal. Ache a matriz <span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>, que representa o operador nesta base, e determine os autovetores normalizados do operador, com seus autovalores. Considere que o espaço é bidimensional.</p>
</div>
<p>Antes de seguir, você deve resolver o problema proposto acima, em detalhe, pelo menos até onde puder, para ter certeza de que está entendo todos os passos necessários à resolução do problema. Ao fazer isso irá encontrar os valores que usaremos na resolução que exemplificada o cálculo de um dos autovetores, a seguir</p>
<div class="admonition example">
<p class="admonition-title">Exemplo: resolução dos autovetores</p>
<p>Os autovalores do problema anterio são <span><span class="MathJax_Preview">\lambda_1=2</span><script type="math/tex">\lambda_1=2</script></span> e <span><span class="MathJax_Preview">\lambda_2=-1</span><script type="math/tex">\lambda_2=-1</script></span>. </p>
<p>Substitui-se, então, esses valores, um de cada vez, na equação de autovalores <span><span class="MathJax_Preview">\hat{T}\ket{u_i}=\lambda_i \ket{u_i}</span><script type="math/tex">\hat{T}\ket{u_i}=\lambda_i \ket{u_i}</script></span> para determinar os autovetores <span><span class="MathJax_Preview">\{ \ket{u_1},\ket{u_2} \}</span><script type="math/tex">\{ \ket{u_1},\ket{u_2} \}</script></span>, como é mostrado abaixo para <span><span class="MathJax_Preview">\ket{u_2}</span><script type="math/tex">\ket{u_2}</script></span>.</p>
<div>
<div class="MathJax_Preview">
\begin{pmatrix}
1 &amp; 2 \\ 
1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
a \\ 
b
\end{pmatrix} = -
\begin{pmatrix}
a \\
b
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\begin{pmatrix}
1 & 2 \\ 
1 & 0
\end{pmatrix}
\begin{pmatrix}
a \\ 
b
\end{pmatrix} = -
\begin{pmatrix}
a \\
b
\end{pmatrix}
</script>
</div>
<div>
<div class="MathJax_Preview">
\Rightarrow a + 2b = -a, \text{ ou } b = -a.
</div>
<script type="math/tex; mode=display">
\Rightarrow a + 2b = -a, \text{ ou } b = -a.
</script>
</div>
<p>portanto,</p>
<div>
<div class="MathJax_Preview">
\ket{u_2}= 
\begin{pmatrix}
a \\
-a
\end{pmatrix}.
</div>
<script type="math/tex; mode=display">
\ket{u_2}= 
\begin{pmatrix}
a \\
-a
\end{pmatrix}.
</script>
</div>
<p>Normalizando o vetor temos:</p>
<div>
<div class="MathJax_Preview">
\bra{u_2} u_2 \rangle = 1 \rightarrow 2a^2 = 1 \Rightarrow a=\frac{1}{\sqrt{2}},
</div>
<script type="math/tex; mode=display">
\bra{u_2} u_2 \rangle = 1 \rightarrow 2a^2 = 1 \Rightarrow a=\frac{1}{\sqrt{2}},
</script>
</div>
<p>portanto, finalmente, temos:</p>
<div>
<div class="MathJax_Preview">
\ket{u_2} = 
\frac{1}{\sqrt{2}}
\begin{pmatrix}
1 \\
-1
\end{pmatrix}.
</div>
<script type="math/tex; mode=display">
\ket{u_2} = 
\frac{1}{\sqrt{2}}
\begin{pmatrix}
1 \\
-1
\end{pmatrix}.
</script>
</div>
<p>Verifique agora que </p>
<div>
<div class="MathJax_Preview"> 
\ket{u_1} = \frac{1}{\sqrt{5}} 
\begin{pmatrix} 
2 \\ 
1 
\end{pmatrix}.
</div>
<script type="math/tex; mode=display"> 
\ket{u_1} = \frac{1}{\sqrt{5}} 
\begin{pmatrix} 
2 \\ 
1 
\end{pmatrix}.
</script>
</div>
</div>
<h3 id="conjugacao-hermitiana">Conjugação Hermitiana</h3>
<p>Até agora vimos que um operador age num <em>ket</em> para produzir um novo <em>ket</em>, de acordo com <span><span class="MathJax_Preview">\hat{T} \ket{u} = \ket{v}.</span><script type="math/tex">\hat{T} \ket{u} = \ket{v}.</script></span> Vejamos agora, mais atentamente, sua ação dentro de um produto interno <span><span class="MathJax_Preview">\bra{w}v\rangle = \braket{w}{\hat{T}}{u}</span><script type="math/tex">\bra{w}v\rangle = \braket{w}{\hat{T}}{u}</script></span>. Sabemos que isso resulta num escalar (número) complexo. </p>
<p>Podemos tomar complexo conjugado desse número, usando a relação <span><span class="MathJax_Preview">\bra{w}v\rangle = \bra{v}w\rangle^*</span><script type="math/tex">\bra{w}v\rangle = \bra{v}w\rangle^*</script></span>. Observe atentamente o que ocorre com o operador</p>
<div>
<div class="MathJax_Preview">
\braket{w}{\hat{T}}{v} = \braket{v}{\hat{T}}{w}^* =\braket{w}{\hat{T^{\dagger}}}{v}
</div>
<script type="math/tex; mode=display">
\braket{w}{\hat{T}}{v} = \braket{v}{\hat{T}}{w}^* =\braket{w}{\hat{T^{\dagger}}}{v}
</script>
</div>
<p>onde <span><span class="MathJax_Preview">\hat{T^{\dagger}}</span><script type="math/tex">\hat{T^{\dagger}}</script></span> (pronuncia-se "T <em>dagger</em>") é chamado de Hermitiado conjugaddo ou adjunto do operador <span><span class="MathJax_Preview">\hat{T}</span><script type="math/tex">\hat{T}</script></span>. </p>
<div class="admonition note">
<p class="admonition-title"><strong>Como formar o Adjunto de uma expressão geral?</strong></p>
<ol>
<li>Substitua qualquer constante por seu complexo conjugado.</li>
<li>Substitua <em>kets</em> pelos <em>bras</em> associados, e vice-versa.</li>
<li>Substitua cada operador por seu Adjunto.</li>
<li>Inverta a ordem de todos os fatores na expressão.</li>
</ol>
</div>
<p><strong>O Hermitiado Conjugado de uma matriz</strong></p>
<p>Já sabemos como encontrar a matriz <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span> de um operador <span><span class="MathJax_Preview">\hat{M}</span><script type="math/tex">\hat{M}</script></span> qualquer. Para encontrar a matriz do Adjunto desse, simbolizada por <span><span class="MathJax_Preview">M^{dagger}</span><script type="math/tex">M^{dagger}</script></span>, basta seguir os seguintes passos:</p>
<div class="admonition note">
<p class="admonition-title"><strong>Matriz Adjunta</strong></p>
<ol>
<li>Calcule a matriz transposta <span><span class="MathJax_Preview">M^T</span><script type="math/tex">M^T</script></span>, trocando as linhas pelas colunas.</li>
<li>Tome o complexo conjugado de cada elemento de <span><span class="MathJax_Preview">M^T.</span><script type="math/tex">M^T.</script></span></li>
</ol>
</div>
<p>De forma resumida:</p>
<div>
<div class="MathJax_Preview">
M^{\dagger}= \left( M^T \right)^*.
</div>
<script type="math/tex; mode=display">
M^{\dagger}= \left( M^T \right)^*.
</script>
</div>
<p><strong>Propriedade da operação de transposição</strong></p>
<div class="admonition note">
<ol>
<li><span><span class="MathJax_Preview">(A+B)^T = A^T + B^T.</span><script type="math/tex">(A+B)^T = A^T + B^T.</script></span></li>
<li><span><span class="MathJax_Preview">(A^T)^T = A.</span><script type="math/tex">(A^T)^T = A.</script></span></li>
<li><span><span class="MathJax_Preview">(aA)^T= a A^T.</span><script type="math/tex">(aA)^T= a A^T.</script></span></li>
<li><span><span class="MathJax_Preview">(AB)^T = B^T A^T.</span><script type="math/tex">(AB)^T = B^T A^T.</script></span></li>
</ol>
</div>
<h3 id="operadores-hermitianos">Operadores Hermitianos</h3>
<p>Um operador é dito Hermitiano quando <span><span class="MathJax_Preview">\hat{T}^{\dagger}=\hat{T}</span><script type="math/tex">\hat{T}^{\dagger}=\hat{T}</script></span>. Para um operador Hemitiano, temos que</p>
<div>
<div class="MathJax_Preview">
\braket{w}{\hat{T}}{v}=\braket{v}{\hat{T}}{w}^*
</div>
<script type="math/tex; mode=display">
\braket{w}{\hat{T}}{v}=\braket{v}{\hat{T}}{w}^*
</script>
</div>
<p>Veremos que os operadores de observáveis físicos na mecânica quântica devem ser sempre operadores Hermitianos. Como esse operadores podem ser representado por matrizes, é interessante ver com determinar se uma matriz é Hemitiana.</p>
<p><strong>Matriz Hermitiana</strong></p>
<p>Uma matriz <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span> é Hermitiana se satisfaz:</p>
<div>
<div class="MathJax_Preview">
M = M^{\dagger}.
</div>
<script type="math/tex; mode=display">
M = M^{\dagger}.
</script>
</div>
<p>Como vimos, <span><span class="MathJax_Preview">M^{\dagger}</span><script type="math/tex">M^{\dagger}</script></span> corresponde ao complexo conjugado da matriz transposta. Portanto, para satisfazer essa condição, os elementos da diagonal principal da matriz devem ser todos números reais (não complexos). Como consequência, o traço do operador (matriz) será, necessariamente um número real.</p>
<p><strong>Autovalores de um operador Hermitiano</strong></p>
<p>Pode-se demonstrar que operadores Hermitianos tem autovalores reais (verifique!). Por conta dessa propriedade, requer-se que todos os observáveis físicos na mecânica quântica, sejam representados por operadores Hermitianos. Portanto, tanto o traço como os autovalores de um operador Hermitiano são números reais. </p>
<p><strong>Operador anti-Hermitiano</strong></p>
<p>Um operador <span><span class="MathJax_Preview">\hat{A}</span><script type="math/tex">\hat{A}</script></span> é dito anti-Hermitiano se:</p>
<div>
<div class="MathJax_Preview">
A^{\dagger}=-A
</div>
<script type="math/tex; mode=display">
A^{\dagger}=-A
</script>
</div>
<p>Verifique que, neste caso, os elementos da diagonal principal do operador (matriz) anti-Hermitiano(a) são todos números imaginários puros.</p>
<h3 id="operadores-unitarios">Operadores Unitários</h3>
<p>Um operador <span><span class="MathJax_Preview">\hat{U}</span><script type="math/tex">\hat{U}</script></span> (de matriz <span><span class="MathJax_Preview">U</span><script type="math/tex">U</script></span>) é unitário se:</p>
<div>
<div class="MathJax_Preview">
UU^{\dagger} = U^{\dagger} U = \mathbb{1}
</div>
<script type="math/tex; mode=display">
UU^{\dagger} = U^{\dagger} U = \mathbb{1}
</script>
</div>
<p>Isso significa que</p>
<div>
<div class="MathJax_Preview">
U^{\dagger} = U^{-1}
</div>
<script type="math/tex; mode=display">
U^{\dagger} = U^{-1}
</script>
</div>
<p>ou seja, que a matriz adjunta é igual a matriz inversa.</p>
<p>Outra importante característica das matrizes unitárias é que as linhas e colunas dessa matrizes formam um conjunto de vetores ortonormais. </p>
<h3 id="comutadores">Comutadores</h3>
<p>Seja <span><span class="MathJax_Preview">\hat{A}</span><script type="math/tex">\hat{A}</script></span> e <span><span class="MathJax_Preview">\hat{B}</span><script type="math/tex">\hat{B}</script></span> dois operadores lineares do espaço. Em geral, temos que <span><span class="MathJax_Preview">\hat{A}\hat{B} \ne \hat{B}\hat{A}.</span><script type="math/tex">\hat{A}\hat{B} \ne \hat{B}\hat{A}.</script></span> Assim, define-se o comutador <span><span class="MathJax_Preview">[\hat{A},\hat{B}]</span><script type="math/tex">[\hat{A},\hat{B}]</script></span> como sendo</p>
<div>
<div class="MathJax_Preview">
[\hat{A},\hat{B}] = \hat{A}\hat{B} - \hat{B}\hat{A}.
</div>
<script type="math/tex; mode=display">
[\hat{A},\hat{B}] = \hat{A}\hat{B} - \hat{B}\hat{A}.
</script>
</div>
<p>Se <span><span class="MathJax_Preview">[\hat{A},\hat{B}]=0</span><script type="math/tex">[\hat{A},\hat{B}]=0</script></span>, dizemos que os operadores comutam. Dois operadores comutam se, e apenas se, eles compartilham uma mesma base de autovetores comuns.</p>
<p><strong>Propriedades do comutador</strong></p>
<div class="admonition note">
<ol>
<li><span><span class="MathJax_Preview">[A,B]=-[B,A]</span><script type="math/tex">[A,B]=-[B,A]</script></span></li>
<li><span><span class="MathJax_Preview">[A+B,C]=[A,C]+[B,C]</span><script type="math/tex">[A+B,C]=[A,C]+[B,C]</script></span></li>
<li><span><span class="MathJax_Preview">[A,BC]=[A,B]C+B[A,C]</span><script type="math/tex">[A,BC]=[A,B]C+B[A,C]</script></span></li>
<li>Se <span><span class="MathJax_Preview">\hat{X}</span><script type="math/tex">\hat{X}</script></span> e <span><span class="MathJax_Preview">\hat{P}</span><script type="math/tex">\hat{P}</script></span> representam os operadores posição e momento linear, então <span><span class="MathJax_Preview">[\hat{X}</span><script type="math/tex">[\hat{X}</script></span>, <span><span class="MathJax_Preview">\hat{P}]=i\hbar</span><script type="math/tex">\hat{P}]=i\hbar</script></span>, enquanto <span><span class="MathJax_Preview">[\hat{X}</span><script type="math/tex">[\hat{X}</script></span>, <span><span class="MathJax_Preview">\hat{X}]= [\hat{P}</span><script type="math/tex">\hat{X}]= [\hat{P}</script></span>, <span><span class="MathJax_Preview">\hat{P}]=0.</span><script type="math/tex">\hat{P}]=0.</script></span> </li>
</ol>
</div>
<h3 id="conjunto-completo-de-observaveis-que-comutam-ccoc">Conjunto Completo de Observáveis que Comutam (CCOC)</h3>
<p>Um conjunto de operadores <span><span class="MathJax_Preview">\hat{A}</span><script type="math/tex">\hat{A}</script></span>, <span><span class="MathJax_Preview">\hat{B}</span><script type="math/tex">\hat{B}</script></span>, <span><span class="MathJax_Preview">\hat{C}, \dots</span><script type="math/tex">\hat{C}, \dots</script></span> forma um CCCO se todos os subpares desses operadores comutam entre si.</p>
<div>
<div class="MathJax_Preview">
[\hat{A},\hat{B}] = [\hat{B},\hat{C}] = [\hat{A},\hat{C}] = \dots= 0
</div>
<script type="math/tex; mode=display">
[\hat{A},\hat{B}] = [\hat{B},\hat{C}] = [\hat{A},\hat{C}] = \dots= 0
</script>
</div>
<p>Isso implica que existe uma base comum de autovetores que é única para todos eles, exceto por um fator mutiplicativo.</p>
                
                  
                    

<hr>
<div class="md-source-date">
  <small>
    
      Última atualização: 30 de abril de 2020
    
  </small>
</div>
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2020  Sérgio R. Muniz  (CC-BY-NC-SA)
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/vendor.36cbf620.min.js"></script>
      <script src="../assets/javascripts/bundle.00c583dd.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copiar para \u00e1rea de transfer\u00eancia", "clipboard.copied": "Copiado para \u00e1rea de transfer\u00eancia", "search.config.lang": "pt", "search.config.pipeline": "", "search.config.separator": "", "search.result.placeholder": "Digite para iniciar a busca", "search.result.none": "Nenhum resultado encontrado", "search.result.one": "1 resultado encontrado", "search.result.other": "# resultados encontrados"}</script>
      
      <script>
        app = initialize({
          base: "..",
          features: [],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.7f7c8775.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_SVG"></script>
      
    
  </body>
</html>